name: Build and Push Docker Image with GitOps

on:
  push:
    branches:
      - dev-kubernetes

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for better commit info
      
      # - name: Create .env file
      #   run: |
      #     cat << EOF > .env
      #     VITE_BASE_SERVICE_URL=${{ vars.DEV_VITE_BASE_SERVICE_URL }}
      #     VITE_FR_SERVICE_URL=${{ vars.DEV_VITE_FR_SERVICE_URL }}
      #     VITE_KEYBOARD_SERVICE_URL=${{ vars.DEV_VITE_KEYBOARD_SERVICE_URL }}
      #     VITE_LIVE_SERVICE_URL=${{ vars.DEV_VITE_LIVE_SERVICE_URL }}
      #     VITE_NEWSGPT_SERVICE_URL=${{ vars.DEV_VITE_NEWSGPT_SERVICE_URL }}
      #     VITE_PUBLIC_TINYMCE_API_KEY=${{ vars.DEV_VITE_PUBLIC_TINYMCE_API_KEY }}
      #     VITE_STT_LIVE_SERVICE_URL=${{ vars.DEV_VITE_STT_LIVE_SERVICE_URL }}
      #     VITE_STT_LIVE_STREAMING_SERVICE_URL=${{ vars.DEV_VITE_STT_LIVE_STREAMING_SERVICE_URL }}
      #     VITE_WORD_CLOUD_BASE_SERVICE_URL=${{ vars.DEV_VITE_WORD_CLOUD_BASE_SERVICE_URL }}
      #     VITE_WORD_CLOUD_IMAGES_URL=${{ vars.DEV_VITE_WORD_CLOUD_IMAGES_URL }}
      #     VITE_WORLDCLOUD_NEWSGPT_URL=${{ vars.DEV_VITE_WORLDCLOUD_NEWSGPT_URL }}
      #     EOF
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Generate Docker tag and variables
        id: vars
        run: |
          COMMIT_HASH=$(echo ${{ github.sha }} | cut -c1-8)
          DOCKER_TAG="jazibumer/formedia:frontend-user-${COMMIT_HASH}"
          
          # Handle commit message safely (escape quotes and newlines)
          COMMIT_MESSAGE=$(echo '${{ github.event.head_commit.message }}' | tr -d '\n' | sed 's/"/\\"/g')
          COMMIT_AUTHOR='${{ github.event.head_commit.author.name }}'
          
          # Check if current commit is a merge commit
          PARENT_COUNT=$(git rev-list --parents -n 1 HEAD | wc -w)
          IS_MERGE_COMMIT=$((PARENT_COUNT > 2))
          
          # Get the previous commit for potential reset
          PREVIOUS_COMMIT=$(git rev-parse HEAD~1)
          
          # Set all outputs
          echo "commit_hash=${COMMIT_HASH}" >> $GITHUB_OUTPUT
          echo "docker_tag=${DOCKER_TAG}" >> $GITHUB_OUTPUT
          echo "commit_message=${COMMIT_MESSAGE}" >> $GITHUB_OUTPUT
          echo "commit_author=${COMMIT_AUTHOR}" >> $GITHUB_OUTPUT
          echo "cache_key=frontend-user-cache" >> $GITHUB_OUTPUT
          echo "is_merge_commit=${IS_MERGE_COMMIT}" >> $GITHUB_OUTPUT
          echo "previous_commit=${PREVIOUS_COMMIT}" >> $GITHUB_OUTPUT
          
          # Debug output
          echo "Generated commit hash: ${COMMIT_HASH}"
          echo "Generated docker tag: ${DOCKER_TAG}"
          echo "Commit message: ${COMMIT_MESSAGE}"
          echo "Commit author: ${COMMIT_AUTHOR}"
          echo "Is merge commit: ${IS_MERGE_COMMIT}"
          echo "Previous commit: ${PREVIOUS_COMMIT}"
      
      - name: Build and push Docker image
        id: docker_build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.vars.outputs.docker_tag }}
          cache-from: |
            type=gha,scope=${{ steps.vars.outputs.cache_key }}
            type=registry,ref=jazibumer/formedia:frontend-user-cache
          cache-to: |
            type=gha,mode=max,scope=${{ steps.vars.outputs.cache_key }}
            type=registry,ref=jazibumer/formedia:frontend-user-cache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
      
      - name: Smart revert on Docker build failure
        if: failure() && steps.docker_build.conclusion == 'failure'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸš¨ Docker build failed! Attempting smart revert..."
          
          # Configure git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Get the current commit info
          CURRENT_COMMIT=$(git rev-parse HEAD)
          COMMIT_MESSAGE="${{ steps.vars.outputs.commit_message }}"
          IS_MERGE_COMMIT="${{ steps.vars.outputs.is_merge_commit }}"
          PREVIOUS_COMMIT="${{ steps.vars.outputs.previous_commit }}"
          
          echo "Current commit: ${CURRENT_COMMIT}"
          echo "Current commit message: ${COMMIT_MESSAGE}"
          echo "Is merge commit: ${IS_MERGE_COMMIT}"
          echo "Previous commit: ${PREVIOUS_COMMIT}"
          
          # Function to revert on a specific branch
          revert_branch() {
            local branch_name=$1
            local strategy=$2
            
            echo "ğŸ”„ Attempting to revert on branch: ${branch_name} using strategy: ${strategy}"
            
            # Fetch and checkout the target branch
            git fetch origin ${branch_name} || {
              echo "âš ï¸ Branch ${branch_name} not found, skipping..."
              return 1
            }
            git checkout ${branch_name}
            
            # Get the latest commit on this branch
            local latest_commit=$(git rev-parse HEAD)
            echo "Latest commit on ${branch_name}: ${latest_commit}"
            
            case "${strategy}" in
              "merge_revert_m1")
                if git revert -m 1 --no-edit HEAD; then
                  echo "âœ… Successfully reverted merge commit on ${branch_name} using -m 1"
                  git push origin ${branch_name}
                  return 0
                fi
                ;;
              "merge_revert_m2")
                if git revert -m 2 --no-edit HEAD; then
                  echo "âœ… Successfully reverted merge commit on ${branch_name} using -m 2"
                  git push origin ${branch_name}
                  return 0
                fi
                ;;
              "regular_revert")
                if git revert --no-edit HEAD; then
                  echo "âœ… Successfully reverted commit on ${branch_name}"
                  git push origin ${branch_name}
                  return 0
                fi
                ;;
              "reset_strategy")
                local prev_commit=$(git rev-parse HEAD~1)
                git reset --soft ${prev_commit}
                git commit -m "ğŸš¨ Revert failed Docker build from ${latest_commit}

          Docker build failed for commit: ${latest_commit}
          Original message: ${COMMIT_MESSAGE}
          Branch: ${branch_name}
          
          This commit reverts the changes to restore a working state.
          
          Auto-reverted by GitHub Actions due to build failure."
                
                if git push origin ${branch_name}; then
                  echo "âœ… Successfully reverted ${branch_name} using reset strategy"
                  return 0
                fi
                ;;
              "force_push")
                local prev_commit=$(git rev-parse HEAD~1)
                git reset --hard ${prev_commit}
                if git push --force-with-lease origin ${branch_name}; then
                  echo "âš ï¸ Force pushed ${branch_name} to previous commit: ${prev_commit}"
                  return 0
                fi
                ;;
            esac
            
            return 1
          }
          
          # Determine if this is likely from a PR from main
          IS_FROM_MAIN_PR=false
          if [ "${IS_MERGE_COMMIT}" = "1" ] && echo "${COMMIT_MESSAGE}" | grep -i "merge pull request"; then
            IS_FROM_MAIN_PR=true
            echo "ğŸ” Detected this is likely a merge from main branch via PR"
          fi
          
          # Strategy 1: Try to revert merge commit on dev-kubernetes
          DEV_REVERTED=false
          if [ "${IS_MERGE_COMMIT}" = "1" ]; then
            echo "ğŸ”„ Attempting to revert merge commit on dev-kubernetes..."
            
            # Ensure we're on dev-kubernetes
            git checkout dev-kubernetes
            
            if revert_branch "dev-kubernetes" "merge_revert_m1"; then
              DEV_REVERTED=true
            elif revert_branch "dev-kubernetes" "merge_revert_m2"; then
              DEV_REVERTED=true
            fi
          else
            # Regular commit revert
            echo "ğŸ”„ Attempting to revert regular commit on dev-kubernetes..."
            git checkout dev-kubernetes
            if revert_branch "dev-kubernetes" "regular_revert"; then
              DEV_REVERTED=true
            fi
          fi
          
          # Strategy 2: Fallback strategies for dev-kubernetes
          if [ "${DEV_REVERTED}" = "false" ]; then
            echo "âš ï¸ Primary revert strategies failed, trying fallback strategies..."
            
            if revert_branch "dev-kubernetes" "reset_strategy"; then
              DEV_REVERTED=true
            elif revert_branch "dev-kubernetes" "force_push"; then
              DEV_REVERTED=true
            fi
          fi
          
          # Strategy 3: Revert main branch if this came from a PR
          MAIN_REVERTED=false
          if [ "${IS_FROM_MAIN_PR}" = "true" ] || [ "${DEV_REVERTED}" = "true" ]; then
            echo "ğŸ”„ Attempting to revert main branch as well..."
            
            # Try to revert main branch
            if revert_branch "main" "regular_revert"; then
              MAIN_REVERTED=true
            elif revert_branch "main" "reset_strategy"; then
              MAIN_REVERTED=true
            elif revert_branch "main" "force_push"; then
              MAIN_REVERTED=true
            else
              echo "âš ï¸ Could not revert main branch - it may not have the same commit"
            fi
          fi
          
          # Create an issue to track the revert
          if [ "${DEV_REVERTED}" = "true" ]; then
            echo "ğŸ“ Creating GitHub issue to track the revert..."
            
            ISSUE_BODY="## ğŸš¨ Automatic Revert Due to Docker Build Failure

          ### ğŸ“‹ Summary
          The Docker build failed for a recent commit, and the following automatic reverts were performed:

          ### ğŸ”„ Revert Details
          - **Failed Commit**: \`${CURRENT_COMMIT}\`
          - **Failed Message**: \`${COMMIT_MESSAGE}\`
          - **Author**: \`${{ github.event.head_commit.author.name }}\`
          - **Workflow Run**: [\`${{ github.run_number }}\`](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ### âœ… Branches Reverted
          - **dev-kubernetes**: ${DEV_REVERTED}
          - **main**: ${MAIN_REVERTED}

          ### ğŸ” Next Steps
          1. Check the failed workflow logs for build errors
          2. Fix the Docker build issues locally
          3. Test the build before creating a new PR
          4. Close this issue once the problem is resolved

          ### ğŸ—ï¸ Build Error
          The Docker build failed during the CI/CD process. Please check the workflow logs for detailed error information.

          **This issue was automatically created by GitHub Actions** ğŸ¤–"

            # Create the issue
            gh issue create \
              --title "ğŸš¨ Auto-revert: Docker build failed for ${CURRENT_COMMIT:0:8}" \
              --body "${ISSUE_BODY}" \
              --label "bug,ci/cd,auto-revert" \
              --assignee "${{ github.event.head_commit.author.username }}" || \
            gh issue create \
              --title "ğŸš¨ Auto-revert: Docker build failed for ${CURRENT_COMMIT:0:8}" \
              --body "${ISSUE_BODY}" \
              --label "bug,ci/cd,auto-revert"
            
            echo "âœ… GitHub issue created to track the revert"
          fi
          
          # Summary
          echo ""
          echo "ğŸ¯ REVERT SUMMARY:"
          echo "=================="
          echo "dev-kubernetes reverted: ${DEV_REVERTED}"
          echo "main branch reverted: ${MAIN_REVERTED}"
          echo "Failed commit: ${CURRENT_COMMIT}"
          echo "Issue created: true"
          echo ""
          
          if [ "${DEV_REVERTED}" = "true" ]; then
            echo "âœ… Successfully reverted the failed build"
          else
            echo "âŒ Failed to revert - manual intervention required"
          fi
          
          # Exit with failure to stop the workflow
          exit 1
      
      # - name: Update GitOps repository
      #   env:
      #     DOCKER_TAG: ${{ steps.vars.outputs.docker_tag }}
      #     HARBOR_TAG: ${{ steps.vars.outputs.harbor_tag }}
      #     COMMIT_HASH: ${{ steps.vars.outputs.commit_hash }}
      #     COMMIT_MESSAGE: ${{ steps.vars.outputs.commit_message }}
      #     COMMIT_AUTHOR: ${{ steps.vars.outputs.commit_author }}
      #   run: |
      #     # Set up git configuration
      #     git config --global user.name "github-actions[bot]"
      #     git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
      #     # Clone the GitOps repository
      #     echo "Cloning GitOps repository..."
      #     git clone https://github-actions:${{ secrets.GITOPS_REPO_SECRET }}@github.com/Formedia-forbmax/gitops.git gitops-repo
      #     cd gitops-repo

      #     git checkout dev-kubernetes 
          
      #     # Verify the deployment file exists
      #     DEPLOYMENT_FILE="frontends/deployments/frontend-user.yaml"
      #     if [ ! -f "$DEPLOYMENT_FILE" ]; then
      #       echo "Error: Deployment file $DEPLOYMENT_FILE not found!"
      #       exit 1
      #     fi
          
      #     echo "Current image in deployment file:"
      #     grep "image: harbor\.forbmax\.ai/formedia/forbmax123/formedia:frontend-user" $DEPLOYMENT_FILE || echo "No matching Harbor image line found"
          
      #     # Create a backup
      #     cp $DEPLOYMENT_FILE ${DEPLOYMENT_FILE}.backup
          
      #     # Update the image tag using Harbor registry format
      #     sed -i.bak "s|image: harbor\.forbmax\.ai/formedia/forbmax123/formedia:frontend-user-[a-zA-Z0-9]*|image: ${HARBOR_TAG}|g" $DEPLOYMENT_FILE
          
      #     # Also handle the case where it might just be the base image without a tag
      #     sed -i.bak2 "s|image: harbor\.forbmax\.ai/formedia/forbmax123/formedia:frontend-user[[:space:]]*#.*|image: ${HARBOR_TAG} # Updated by GitHub Actions|g" $DEPLOYMENT_FILE
          
      #     echo "Updated image in deployment file:"
      #     grep "image: harbor\.forbmax\.ai/formedia/forbmax123/formedia:frontend-user" $DEPLOYMENT_FILE || echo "No matching Harbor image line found after update"
          
      #     # Check if there are any changes
      #     if git diff --quiet $DEPLOYMENT_FILE; then
      #       echo "No changes detected in deployment file"
      #       echo "This might indicate the sed command didn't match or the image was already up to date"
      #       exit 1
      #     fi
          
      #     # Show the diff for debugging
      #     echo "Changes made:"
      #     git diff $DEPLOYMENT_FILE
          
      #     # Commit and push changes
      #     git add $DEPLOYMENT_FILE
      #     git commit -m "ğŸš€ Update frontend-user image to ${COMMIT_HASH}
      #     ğŸ“¦ Docker Hub: ${DOCKER_TAG}
      #     ğŸ—ï¸ Harbor: ${HARBOR_TAG}
      #     ğŸ‘¤ Author: ${COMMIT_AUTHOR}
      #     ğŸ’¬ Original: ${COMMIT_MESSAGE}
      #     ğŸ”— Source: ${{ github.repository }}@${{ github.sha }}"
          
      #     echo "Pushing changes to GitOps repository..."
      #     git push origin HEAD:dev-kubernetes
          
      #     echo "âœ… Successfully updated GitOps repository!"
      
      - name: Create Pull Request to staging-kubernetes
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸ”„ Creating Pull Request from dev-kubernetes to staging-kubernetes..."
          
          # Ensure we're on the right branch
          git fetch origin
          git checkout dev-kubernetes
          
          # Check if staging-kubernetes branch exists
          if ! git ls-remote --heads origin staging-kubernetes | grep staging-kubernetes; then
            echo "âš ï¸ staging-kubernetes branch doesn't exist. Creating it from dev-kubernetes..."
            git checkout -b staging-kubernetes
            git push origin staging-kubernetes
            git checkout dev-kubernetes
          fi
          
          # Safely handle commit message (escape special characters)
          SAFE_COMMIT_MESSAGE=$(echo "${{ steps.vars.outputs.commit_message }}" | sed 's/"/\\"/g' | tr -d '\n')
          
          # Create PR using GitHub CLI
          PR_BODY="## ğŸ“¦ Docker Image Promotion

          **Promoting frontend-user image to staging environment**

          ### ğŸ” Details
          - **Docker Image**: \`${{ steps.vars.outputs.docker_tag }}\`
          - **Source Branch**: \`dev-kubernetes\`
          - **Target Branch**: \`staging-kubernetes\`
          - **Commit Hash**: \`${{ steps.vars.outputs.commit_hash }}\`
          - **Full SHA**: \`${{ github.sha }}\`
          - **Author**: \`${{ steps.vars.outputs.commit_author }}\`
          - **Original Message**: \`${SAFE_COMMIT_MESSAGE}\`

          ### ğŸ§ª Testing Status
          - âœ… Docker build successful
          - âœ… Image pushed to registry
          - âœ… Ready for staging deployment

          ### ğŸ¯ Changes
          This PR promotes the latest frontend-user changes from development to staging environment.

          **Auto-generated by GitHub Actions** ğŸ¤–

          Workflow: \`${{ github.workflow }}\`
          Run: \`${{ github.run_number }}\`"

          # Check if PR already exists
          EXISTING_PR=$(gh pr list --base staging-kubernetes --head dev-kubernetes --json number --jq '.[0].number' 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ] && [ "$EXISTING_PR" != "" ]; then
            echo "ğŸ“ Updating existing PR #${EXISTING_PR}..."
            gh pr edit $EXISTING_PR \
              --body "$PR_BODY" \
              --title "ğŸš€ Promote frontend-user to staging (Updated: ${{ steps.vars.outputs.commit_hash }})"
            echo "âœ… Updated existing PR #${EXISTING_PR}"
          else
            echo "ğŸ“ Creating new Pull Request..."
            
            # Create PR with error handling
            if PR_URL=$(gh pr create \
              --base staging-kubernetes \
              --head dev-kubernetes \
              --title "ğŸš€ Promote frontend-user to staging (${{ steps.vars.outputs.commit_hash }})" \
              --body "$PR_BODY" \
              --label "enhancement" \
              --assignee "${{ github.actor }}" 2>/dev/null); then
              
              echo "âœ… Pull Request created successfully!"
              echo "ğŸ”— PR URL: $PR_URL"
            else
              echo "âš ï¸ Failed to create PR with assignee/reviewer, trying without..."
              PR_URL=$(gh pr create \
                --base staging-kubernetes \
                --head dev-kubernetes \
                --title "ğŸš€ Promote frontend-user to staging (${{ steps.vars.outputs.commit_hash }})" \
                --body "$PR_BODY" \
                --label "enhancement")
              
              echo "âœ… Pull Request created successfully!"
              echo "ğŸ”— PR URL: $PR_URL"
            fi
          fi
      
      - name: Summary
        if: success()
        run: |
          echo "ğŸ‰ Deployment completed successfully!"
          echo "ğŸ“¦ Docker image pushed: ${{ steps.vars.outputs.docker_tag }}"
          echo "ğŸ”– Commit hash: ${{ steps.vars.outputs.commit_hash }}"
          echo "ğŸ“ Pull request created/updated for promotion to staging-kubernetes branch"
          echo "ğŸ¤– Ready for staging deployment approval!"
